# -*- coding: utf-8 -*-
"""Project 2: Dijkstra’s Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cW1sdpq0xX4DreqkVwEmaaWg_iy0T13P

# Project 2 : Dijkstra's Algorithm

## (a) Suppose the input graph G = (V, E) is stored in an adjacency matrix and we use an array for the priority queue. Implement the Dijkstra’s algorithm using this setting and analyze its time complexity with respect to |V| and |E| both theoretically and empirically

### Libraries and data structures needed
"""

# Pandas and Plotly.express for data visualization purposes
import pandas as pd
import plotly.express as px

# Numpy and Scipy.sparse.rand for generating randomised arrays
import numpy as np
from scipy.sparse import rand

# Time for generation of CPU times, to be used further for visualization purposes
import time

# Sys for using sys.maxsize to indicate INFINTIY
import sys

sparse_test=[]
dense_test=[]

"""### Utility Functions"""

def sparse_mat_gen(n):
  arr = np.array(abs(rand(n,n,format="csr",random_state=69, density=0.30).todense()))
  for i in range(n):
    if arr[i][i]!=0:
      arr[i][i]=0
  return arr

matrix = sparse_mat_gen(4)
matrix

def test_for_sparse(n,time_arr):
  for i in range(1,n):
    g=Graph(n)
    g.graph=sparse_mat_gen(n)
    start=time.time()
    g.dijkstra(0)
    end=time.time()
    timer=end-start
    #print("--- %s seconds ---" % timer)
    time_arr.append(timer)

def dense_mat_gen(n):
  arr = np.array(abs(rand(n,n,format="csr",random_state=69, density=0.89).todense()))
  for i in range(n):
    if arr[i][i]!=0:
      arr[i][i]=0
  return arr

matrix = dense_mat_gen(6)
print(matrix)

def test_for_dense(n,time_arr):
  for i in range(1,n):
    g=Graph(n)
    g.graph=dense_mat_gen(n)
    start=time.time()
    g.dijkstra(0)
    end=time.time()
    timer=end-start
    #print("--- %s seconds ---" % timer)
    time_arr.append(timer)

"""### Graph construction and traversal using Dijkstra's Algorithm"""

# to intialise distances to INFINITY, we import sys so as to use sys.maxsize
import sys
 
class Graph():
    def __init__(self,vertices):
      '''intialise graph constructor using various attributes''' 
      self.vertices = vertices
        
      # intialise the adjacency matrix to all 0s
      self.graph = [[0 for column in range(vertices)] for row in range(vertices)]
        
      # False for not visited, True for visited
      self.visited = [False for i in range(vertices)] 
        
      # initialise all distances from source to INFINITY
      self.d = [sys.maxsize for i in range(vertices)]

      # pi = array of predecessors for each vertex
      self.pi = [None for i in range(vertices)] #set all piecessor to None
        
      # Q = priority queue to store which vertex to visit next
      self.Q = []
        
    
    def dijkstra(self,source): 
        '''source refers to the source node
           function dijkstra is to traverse the directed weighted graph
           using the Dijkstra's algorithm which is a greedy algorithm,
           along with the implementation of a priority queue, as specified
           in the question, we have used an array for the same'''
        
        # set the distance of the source from source as 0
        self.d[source] = 0
           
        # insert source into the priority queue
        self.enqueue(source)
      
        # while the priority queue Q is not empty
        while (len(self.Q) > 0):
                
                # find vertex with min distance, i.e. top of the queue
                u = self.dequeue() 
                
                for j in range(self.vertices):
                  if self.d[j] > self.d[u] + self.graph[u][j] and self.graph[u][j] != 0 and self.visited[j]!=True:
                    
                    #update the distance array accordingly
                    self.d[j] = self.d[u] + self.graph[u][j]

                    #update the predecessor array accordingly
                    self.pi[j] = u

                    #insert 'j' into the priority queue according to its d[j]
                    self.enqueue(j)

            
        # print("The shortest distance to all the vertices from source node is: ")
        # print(self.d)


    def enqueue(self, v):
        '''to maintain the property of the priority queue while insertion, i.e.
           sort in the order of d[v]'s increasing order'''

        # if the priority queue is empty, just insert the vertex v
        if (len(self.Q) == 0):
            self.Q.append(v)
        else:
            # i = counter variable
            i = 0

            # otherwise, find the correct position for vertex to be inserted
            while (self.d[i] >= self.d[v]):
                i = i + 1
            
            # insert it at the right position
            self.Q.insert(i, v)
            

    def dequeue(self):
        '''to maintain the property of the priority queue while deletion'''

        u = self.Q[len(self.Q)-1]
        self.Q.pop(len(self.Q)-1)
        return u

"""### Testing Section"""

g=Graph(5)
inf = sys.maxsize
#graph = dense_mat_gen(n)
g.graph = [[0, 4, 2, inf, inf],
           [inf, 0, 3, 2, 3],
           [inf, 1, 0, 4, 5],
           [inf, inf, inf, 0, inf],
           [inf, inf, inf, 1, 0]]
g.dijkstra(0)

g1=Graph(5)
#graph = dense_mat_gen(n)
g1.graph = [[0, 4, 2, 0, 0],
           [0, 0, 3, 2, 3],
           [0, 1, 0, 4, 5],
           [0, 0, 0, 0, 0],
           [0, 0, 0, 1, 0]]
g1.dijkstra(0)

n = int(input("Enter end value of range : "))

import time
total_time = 0
total_run = 10
n = 250

for x in range(total_run):
    g=Graph(n)
    g.graph=sparse_mat_gen(n)
    start=time.time()
    g.dijkstra(0)
    end=time.time()
    total_time = total_time = (end - start)

print(f"When nodes = {n}, Average Execution time = {total_time/total_run}")

test_for_dense(n,dense_test)

test_for_sparse(n,sparse_test)

"""### Data Visualization Section"""

sparse_df=pd.DataFrame(sparse_test)
dense_df=pd.DataFrame(dense_test)

fig = px.line(x = [i for i in range(1,n)] ,
              y = dense_df,
              title = 'Densely populated adjacency matrix')
fig.show()

fig = px.line(x = [i for i in range(1,n)] ,
              y = sparse_df,
              title = 'Sparsely populated adjacency matrix')
fig.show()

"""## (b) Suppose the input graph G = (V, E) is stored in an array of adjacency lists and we use a minimizing heap for the priority queue. Implement the Dijkstra’s algorithm using this setting and analyze its time complexity with respect to |V| and |E| both theoretically and empirically. tion

### Libraries Needed
"""

from random import randint
from time import process_time

"""### Driver Code


"""

# driver code
global size 
size = 100000
def makeDenseGraph():
    # stores the number of vertices in the graph
    global denseGraph 
    denseGraph = {}
    
 
    for x in range(size):
        add_vertex(x,denseGraph)
 
    for vertex in denseGraph:
        no_of_edges = randint(size//2,size-1)
        check=[]
        for x in range(size):
            check.append(False)
        while no_of_edges != 0:
            connected_vertex = randint(0,size-1)
            if connected_vertex != vertex and check[connected_vertex-1]==False:
                add_edge(vertex, connected_vertex, randint(1,10),denseGraph)
                no_of_edges -=  1
                check[connected_vertex-1]=True
            else:
                connected_vertex = randint(0,size-1)
    #print ("Dense Graph: ", denseGraph)

def makeSparseGraph():
    # stores the number of vertices in the graph
    global sparseGraph 
    sparseGraph = {}

    for x in range(size):
        add_vertex(x,sparseGraph)
 
    for vertex in sparseGraph:
        no_of_edges = randint(0,size//2)
        check=[]
        for x in range(size):
            check.append(False)
        while no_of_edges != 0:
            connected_vertex = randint(0,size-1)
            if connected_vertex != vertex and check[connected_vertex-1]==False:
                add_edge(vertex, connected_vertex, randint(1,10),sparseGraph)
                no_of_edges -=  1
                check[connected_vertex-1]=True
            else:
                connected_vertex = randint(0,size-1)
    #print ("Sparse Graph: ", sparseGraph)
# Add a vertex to the dictionary
def add_vertex(v,graph):
  graph[v] = []
 
# Add an edge between vertex v1 and v2 with edge weight e
def add_edge(v1, v2, e,graph):
  
  # Check if vertex v1 is a valid vertex
  if v1 not in graph:
    print("Vertex ", v1, " does not exist.")
  # Check if vertex v2 is a valid vertex
  elif v2 not in graph:
    print("Vertex ", v2, " does not exist.")
  else:
    # Since this code is not restricted to a directed or 
    # an undirected graph, an edge between v1 v2 does not
    # imply that an edge exists between v2 and v1
    temp = [v2, e]
    graph[v1].append(temp)

"""### Graph and Heap (and its utility functions) construction



"""

class Heap():
    def __init__(self):
        self.array = []
        self.size = 0
        self.pos = []
        
    def newNode(self,v, dist):
        node = [v, dist]
        return node
 
    def swapMinHeapNode(self,a, b):
        t = self.array[a]
        self.array[a] = self.array[b]
        self.array[b] = t
 
    #will be heapifying the heap when parent node is removed
    def minHeap(self,parent):
        smallest = parent
        left = 2*parent+1
        right = 2*parent+2
        #To check whether the left node is smaller compared to right
        if left < self.size and self.array[left][1] < self.array[smallest][1]:
            smallest = left
 
        #To check whether the right node is smaller compared to left
        if right < self.size and self.array[right][1] < self.array[smallest][1]: 
            smallest = right
 
        #it will swap the smaller child node with parent node IFF child node is smaller than parent node 
        if smallest != parent:
            # Swap positions
            self.pos[self.array[smallest][0]] = parent
            self.pos[self.array[parent][0]] = smallest
            
            self.swapMinHeapNode(smallest,parent)
 
            self.minHeap(smallest)
    
    def extractMin(self):
        # Return NULL wif heap is empty
        if self.isEmpty() == True:
            return
 
        # Store the root node
        root = self.array[0]
 
        # Replace root node with last node
        lastNode = self.array[self.size - 1]
        self.array[0] = lastNode
 
        # Update position of last node
        self.pos[lastNode[0]] = 0
        self.pos[root[0]] = self.size - 1
 
        # Reduce heap size and heapify root
        self.size -= 1
        self.minHeap(0)
 
        return root
        
    def isEmpty(self):
        return True if self.size == 0 else False
 
    def decreaseKey(self, v, dist):
 
        # Get the index of v in  heap array
 
        i = self.pos[v]
 
        # Get the node and update its dist value
        self.array[i][1] = dist
 
        # Travel up while the complete tree is
        # not hepified. This is a O(Logn) loop
        while i > 0 and self.array[i][1] < self.array[(i - 1) // 2][1]:
 
            # Swap this node with its parent
            self.pos[ self.array[i][0] ] = (i-1)//2
            self.pos[ self.array[(i-1)//2][0] ] = i
            self.swapMinHeapNode(i, (i - 1)//2 )
 
            # move to parent index
            i = (i - 1) // 2;
 
    def isInMinHeap(self, v):
 
        if self.pos[v] < self.size:
            return True
        return False

 
def dijkstra(src,graph):
 
    V = size  # Get the number of vertices in graph
    dist = []   # dist values used to pick minimum
                    # weight edge in cut
 
    # minHeap represents set E
    minHeap = Heap()
 
    #  Initialize min heap with all vertices.
    # dist value of all vertices
    for v in range(size):
        dist.append(999)
        minHeap.array.append(minHeap.newNode(v, dist[v]))
        minHeap.pos.append(v)
 
      # Make dist value of src vertex as 0 so
      # that it is extracted first
    minHeap.pos[src] = src
    dist[src] = 0
    minHeap.decreaseKey(src, dist[src])

    # Initially size of min heap is equal to V
    minHeap.size = V;

    # In the following loop,
    # min heap contains all nodes
    # whose shortest distance is not yet finalized.
    while minHeap.isEmpty() == False:

        # Extract the vertex
        # with minimum distance value
        newHeapNode = minHeap.extractMin()
        u = newHeapNode[0]

        # Traverse through all adjacent vertices of
        # u (the extracted vertex) and update their
        # distance values
        for pCrawl in graph[u]:

            v = pCrawl[0]

            # If shortest distance to v is not finalized
            # yet, and distance to v through u is less
            # than its previously calculated distance
            if minHeap.isInMinHeap(v) and dist[u] != 999 and pCrawl[1] + dist[u] < dist[v]:
                dist[v] = pCrawl[1] + dist[u]
                # update distance value
                # in min heap also
                minHeap.decreaseKey(v, dist[v])
    #printArr(dist,V)

"""### Utility Functions"""

def printArr(dist, n):
    print ("Vertex\tDistance from source")
    for i in range(n):
        print ("%d\t\t%d" % (i,dist[i]))

#Print the graph
def print_graph(graph):
  for vertex in graph:
    print(vertex, "->", end=" ")
    for edges in graph[vertex]:
      print("(",edges[0],",",edges[1],")", "->",end = " ")
    print("\n")

"""### Testing Section"""

makeDenseGraph()
makeSparseGraph()

t1_dense_start = process_time()
dijkstra(1,denseGraph)
t1_dense_stop = process_time()

t1_sprase_start = process_time()
dijkstra(1,sparseGraph)
t1_sprase_stop = process_time()

print("Elapsed time: ", t1_dense_stop, t1_dense_start)

print("Total time taken for process (dense): ", t1_dense_stop - t1_dense_start,"s")

print("Elapsed time: ", t1_sprase_stop, t1_sprase_start)

print("Total time taken for process(sparse): ", t1_sprase_stop - t1_sprase_start,"s")